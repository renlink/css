# viewport的两个故事



## 第一部分 （pc桌面）

在这节中，我将说明viewports和重要元素的宽度是如何工作的，比如`<html>`元素、window和 scrren的宽度。

这篇文章是关于桌面浏览器的，目的是为介绍移动浏览器做好准备。大部分的web开发者已经对桌面浏览器的一些概念很熟悉了。在移动浏览器上我们会发现同样的概念，只不过要更复杂一些，回顾一下这些熟悉的概念将对我们理解移动浏览器有很大的帮助。



### 设备像素和css像素

你需要理解的第一个概念是css像素和设备像素之间的区别。

设备像素，顾名思义，无论你用什么设备，设备像素都是表示设备的实际分辨率。**设备像素可以从`screen.width/height`读取。**

如果你给一个元素`widht:128px`,你的显示器是1024px宽，你最大化你的浏览器，这个元素可以在屏幕上平铺8个。(大概；忽略一些不确定因素)

如果用户缩放了页面，这个值将发生改变。如果用户放大浏览器到200%，你的128px的元素只能在屏幕上平铺4个了。

用户缩放在浏览器中是通过拉伸像素实现的。也就是说，元素的宽度并没有从128px变成256px，而是像素的尺寸变成了原来的两倍。综上，这个元素仍旧有128px的css像素,但是此时它却占有256px的设备像素。

换句话说，放到到200%使一个css像素尺寸了变成了4倍的设备像素的尺寸。(两倍的宽，两倍的高)。

下面几个图片可以很清楚的说明这个概念。第一个是缩放为100%，这个没什么可看的。css像素完全覆盖了设备像素。

![](css3_img\css像素放大.png)

现在我们缩小页面。css像素开始缩小，意味着一个设备像素可以覆盖若干个css像素。

![](css3_img\css像素缩小.png)

如果你放大，相反的事情就发生了。css像素开始变大，现在一个css像素可以覆盖若干个设备像素

![](css3_img\css像素放大2.png)

关键点在于你只需要关系css像素，它决定你的样式如何渲染。

设备像素对于你来说几乎是无用的。对用户来说不是，用户会缩放页面直到页面看起来舒服位置。但是这个缩放比对你来说不重要，浏览器会自动根据缩放比来缩小或者放大的你的css像素。





### 100% 缩放

上面提到的例子，前提是100%的缩放。现在可以更严格的定义一下：

```
在100%缩放的情况下，css像素和设备像素是严格相等的。
```

这100%缩放的概念在我们的这个解释中是非常有用的，但是我们在日常开发中不需要过度担心这个。在桌面浏览器开发中通常你都是在100%缩放的情况下，即使用户缩放页面，css像素的原理也能保证你的布局保持比例，不被打乱。





### screen size（设备屏幕宽高）

让我们来看一下实际的尺寸吧。我们从**`screen.width`和`screen.height`**开始。他们表示用户屏幕的总宽度和总高度。**他们的单位是设备像素**，因为它们从来不会改变：**它们是显示器的特性，不是浏览器的特性。**

![](css3_img\屏幕宽高.jpg)

很有意思！但是我们能用这个信息做什么呢？

基本没有用。用户的显示器尺寸对我们来说不重要，除非你想做一个web资料数据库。







### window size（窗口可视区域宽高）

相反，你关心的是浏览器窗口的内部尺寸是什么。那会告诉你用于展示你的css布局的空间是多大。你可以通过`window.innerWidth`和`window.innerHeight`来获取。

![](css3_img\window size.jpg)

很明显，窗口的内部宽度的单位是css像素。你需要知道的是你的css布局有多少可以呈现在浏览器窗口中，而且这个呈现的数量会随着用户放大页面而减少(css像素越大，所呈现的内容越少)。因此如果用户放大页面，你可用的空间也就越少，在`window.innerWidth/Height`反应为值减小。

![](css3_img\window size2.jpg)

**注意！这个宽度和高度包括滚动条。滚动条也被认为是浏览器窗口的一部分。(这个有历史的原因)**







### scrolling offset（滚动偏移）

`window.pageXOffset`和`window.pageYOffset`,表示document横向和纵向的滚动偏移。通过这两个属性，你可以知道用户滚动的位置

![](css3_img\滚动偏移.jpg)

**这两个属性的单位也是css像素**。理论上，如果用户向上滚动然后放大，`window.pageX/YOffset`应该发生改变。但是浏览器做了一些处理，在用户缩放的时候，浏览器试图使同一个元素保持在浏览器窗口的顶部来使页面看起来不会跳动。这意味着`window.pageX/YOffset`在用户缩放的时候不会改变：**被滚动出屏幕的css像素数不会改变。**

![](css3_img\滚动偏移2.jpg)







### html宽度与viewport的关系

在我们继续介绍更多的js属性之前，我们必须介绍另外一个概念：viewport。

**viewport的作用是限制`<html>`元素，是网站的最顶级的块级元素。**

这听起来或许有一点模糊，我们来举一个实际的例子。假设你有一个流体布局，你的侧边栏是`width:10%`.当你调整浏览器的大小时，侧边栏随着增大或减小。那它到底是怎么工作的那？

从技术上说，侧边栏在获取它父元素的宽度的10%的时候发生了什么。我们假定`<body>`元素为父元素。所以现在问题变成了`<body>`元素（你没有给`<body>`赋宽度）的宽度是多少。

通常来说，所有的块级元素的宽度都是父元素的宽度的100%。因此`<body>`元素是和它的父元素`<html>`一样宽的。

现在`<html>`元素的宽度是多少那？为什么它和浏览器一样宽。这也是为什么你的`width:10%`的侧边栏占整个浏览器宽度的10%的原因。所有的web开发者都知道这个事实。

你或许不知道这其中的工作原理。理论上，**html元素的宽度是被viewport的宽度限制的。html元素等于viewport的宽度。**

viewport和浏览器窗口相等的：它就是这么被定义的。viewport不是一个HTML结构，所以你不能靠css影响它。它就是有浏览器窗口的宽度和高度(桌面);在移动浏览器上它是比较复杂的。



这些东西有时候会有一些奇怪的结果。能从这个网站看出来

https://www.quirksmode.org/mobile/viewports.html

缩小窗口或者放大页面，现在滚动到最右边，你将会看到顶部的蓝色栏不再被正确的排列。

![](css3_img\元素溢出.jpg)

这个行为是viewport被定义的方式导致的。给了蓝色顶部栏一个`width:100%`.什么的100%？html元素的100%。`<html>`元素和viewport是等宽的，所以和浏览器窗口也是等宽的。

重点是：**在100%缩放时，它是正常的，放大页面的时候，导致viewport变的比我们html页面的总宽度小。**对于html它自己来说这不重要，但是页面的内容溢出了html元素，因为`[overflow](http://www.quirksmode.org/css/overflow.html): visible`，这就意味着超出的元素会被显示。

但是蓝色顶部栏没有溢出。我给了它width:100%,浏览器会给它一个viewport的宽度。他们不关心现在的宽度太小了。

![](css3_img\元素溢出2.jpg)





### document width（页面宽高）

真正想知道的是页面内容的总宽度是多少，包括突出的部分。然而，浏览器貌似并未提供这个值。

我们需要一个js属性对来表示我称作"document width"的值。

![](css3_img\document width.jpg)

如果我们真是觉得这样不爽，为什么不把document width的值暴露给css那？我希望蓝色顶部栏继承document宽度，而不是html元素的宽度。（这个确实有些棘手，如果不可能实现我也不会觉得惊讶）



那么我们从哪里获取html元素自身的宽和高那？他们可以通过`document.documentElement.offsetWidth/offsetHeight`获取。

![](css3_img\html真实宽高.jpg)

这两个属性真地给了你一个访问`<html>`元素作为块级元素的接口。如果你设置`width`或者`offsetWidth`将会影响这两个属性。

![](css3_img\html真实宽高2.jpg)











### viewport 尺寸

想要知道viewport的尺寸。可以通过`document.documentElement.clientWidth/clientHeight`来获取.

![](css3_img\viewport尺寸.jpg)

如果你了解dom结构，你就知道`document.documentElement`其实是`<html>`元素：`<html>`文档的根元素。然而，viewport是更高一级的，可以说它是包含`<html>`元素的元素。如果你给了`<html>`元素一个宽度，那就变得比较重要了(不推荐这样做，但是这是可以的)。即使在这种情况下，`document.documentElement.clientWidth/clientHeight`仍旧给出的是viewport的尺寸，而不是html的尺寸。(这是一个只对这个元素和这个属性对起作用的特例。其他情况下`clientWidth/clientHeight`都是取元素的真实尺寸)。

![](css3_img\viewport尺寸2.jpg)

**注意！这个宽度和高度不包括滚动条。滚动条被认为是浏览器窗口的一部分，但不是viewport 的一部分。**







### window size 与 viewport size

那么viewport的尺寸是不是也可以由`window.innerWidth/Height`给出。答案是也不是，前提的判断标准为有没有滚动条并且没有手动设置meta viewport的width值。

这两对属性值的唯一区别在于，**`window.innerWidth/Height`包括滚动条的宽度**，**`document.documentElement.clientWidth/clientHeight`不包括。**

之所以有两对属性是浏览器大战的产物。当时Netscape只支持`window.innerWidth/Height`，而IE只支持`document.documentElement.clientWidth/clientHeight`。当所有其他浏览器开始支持`document.documentElement.clientWidth/clientHeight`的时候，IE仍旧不支持`window.innerWidth/Height`.在桌面浏览器上有两个属性对是一个烦人的事情，但是在移动浏览器上它是一个福音。







### 事件坐标

有一些事件坐标值。当一个鼠标事件发生时，不少于5对属性值会被暴露出来给你事件发生的具体位置信息。其中3对是对我们的讨论来说重要的：

> 1. pageX/Y给出相对于html元素的坐标，单位是css像素
>
> 2. clientX/Y给出相对于viewport的坐标，单位是css像
> 3.  screenX/Y给出相对于屏幕的坐标，单位是设备像素

**pageX/Y**

![](css3_img\pageX-Y.jpg)

**clientX/Y**

![](css3_img\clientX-Y.jpg)

**screenX/Y**

![](css3_img\screenX-Y.jpg)

90%的情况下都会使用`pageX/Y`;通常你想要知道相对于document的位置。其他的10%你想要用`clientX/Y`.你基本不需要知道相对于屏幕的尺寸





### device-width/device-height

有两个相关的媒体查询：`width/height` 和 `device-width/device-height`.

```
1. `width/height`用的是`documentElement.clientWidth/height`（就是viewport）。单位是css像素。
2. `device-width/device-height`用的是`screen.width/height`.单位是设备像素。
```

![](css3_img\device-width  or height.jpg)

在pc端应该用哪个宽度？想都不用想，当然是`width`。web开发者对设备宽度不感兴趣，只是对浏览器窗口的宽度感兴趣。

在桌面浏览器上使用`width`，忘记`device-width`.正如我们所看到的，然而这在移动设备上是更复杂的，必须得了解的。













## 第二部分 （移动端）

在这节中，我将解释 viewports 和各种重要元素的宽度是如何工作的，比如说 `<html>` 元素，窗口以及屏幕。

在此讨论移动端浏览器。如果你是刚刚接触移动端，我建议你首先阅读关于桌面浏览器的[上文第一部分或者原作者的文章](http://quirksmode.org/mobile/viewports.html)。这会让你在熟悉的环境中循序渐进。





### 移动端浏览器的问题

手机浏览器与桌面浏览器的最大不同就是屏幕尺寸。对于一个基于pc桌面设计的网站，移动端浏览器的显示效果明显不如桌面浏览器，要么缩小后文字太小无法阅读，要么放大后只能看到网站的一部分。

手机屏幕是远小于桌面屏幕的

平板设备如 ipad 以及传闻基于 webOs 的惠普产品将缩小桌面与手机的差距，但也无法改变最基本的问题。因为网站也需要在移动端显示，所以我们必须让它们在小屏幕上正常显示。

最重要的**问题与 CSS 有关**，尤其视图的尺寸。如果我们一比一的复制桌面的布局模型，CSS 可能不会在移动端正常工作。

将侧边栏设置为 `width: 10%` 。如果移动浏览器和桌面浏览器的工作原理相同，1个css像素对应1个设备像素，侧边栏就显示的太窄了。你的自适应布局看上去被压扁了。

解决这个问题的方法之一就是为移动浏览器设计单独的网站。然而实际的问题是只有很少的网络公司会为移动端单独设计网站。

手机浏览器的供应商希望为客户提供最好的用户体验，这意味着“尽可能如桌面显示的一样”。因此必须使用一些**小花招**。







### 三个viewport

视窗太小而不能满足你 CSS 布局的基础。很明显解决方式就是让视窗更宽一点，我们要将视图分为两部分：视觉视窗和布局视窗。

George Cummins 在 Stack Overflow 上很好的解释了视窗的基本概念，“把布局视窗想象成一张无法改变大小和形状的很大的图片，你可以通过一个很小的相框来看这张图片。这个小相框的周围是不透明的材料，你只能看到相框内的图片。你从相框内看到的图片就是视觉视图。你可以拿着你的相框远离图片来看整张图片（缩小），或者离近一点只看图片的一部分（放大）。你也可以改变相框的角度，但是图片（视觉视图）的大小和尺寸不会变。”

 通过**视觉视窗**只能看到页面的一部分，也就是可视区域，如下所示。用户可以通过滚动来查看页面，或者通过缩放改变视觉视窗的大小

![](css3_img\可视视窗2.png)

CSS 的布局是根据**布局视图**计算的，所以比视觉视图更宽。

由于 `<html>` 元素首先获取布局视图的尺寸，所以 CSS 被编译后页面就会比手机屏幕宽。这使得你的网站和在桌面浏览器中显示的一样。

布局视图有多宽呢？不同的浏览器各有差异。Safari/980px，Opera/850px，Android Webkit/800px，IE/974px。







**缩放**

很明显，两种视图都是用 CSS 像素测算。当视觉视图通过缩放改变时（如果是放大，屏幕上的 CSS 像素会变少），布局视图的尺寸不会变。（如果变化了，你的页面会用百分比的宽度被重新计算）





### 理解布局视窗

为了理解布局视图的尺寸，我们应该看一下页面被完全缩小后发生了什么。**大多数手机浏览器默认以完全缩小模式显示页面**。

关键的一点是：布局视图在缩小模式下能够完全显示在屏幕上。（此时视觉视图等于布局视图）

![](css3_img\布局视窗2.png)

如下图，布局视图的宽高与完全缩小模式下的宽高是相同的。当用户放大后，这些尺寸仍然相同。

![](css3_img\布局视窗3.png)

布局视图的宽度始终相同。如果你旋转手机，视觉视图会发生改变，但是浏览器会放大布局视图来适应新的方向，所以布局视图和视觉视图的宽度仍然相等。

![](css3_img\布局视窗4.png)

这会对布局视图的高度产生影响，纵向模式下布局视图的高度小于实际高度。但是网页开发者不需要关心高度，只关心宽度就可以，因为高度会随着网页的内容变多而增高。

![](css3_img\布局视窗5.png)







### 布局视窗的大小

 `document.documentElement.clientWidth` 和 `-Height` 包含了布局视图的尺寸。

![](css3_img\布局视图宽高.jpg)

旋转方向会影响高度，但不会影响宽度。

![](css3_img\布局视图宽高.jpg)







### 视觉视窗的大小

视觉视图通过 `window.innerWidth/Height` ``测算。很明显，当用户放大或缩小时，由于更多或更少的 CSS 像素会适配屏幕，视觉视图尺寸会发生变化。

![](css3_img\视觉视图宽高.jpg)

不幸的是这种方法并不兼容。很多浏览器仍然需要增加对视觉视图尺寸的支持。还没有浏览器具有其他保存该尺寸的属性值。所以我猜想 `window.innerWidth/Height` 是一个标准属性，尽管支持性不太好。









### 屏幕大小

和在桌面上一样， `screen.width/height` 能够得到屏幕的尺寸（设备像素）。作为开发者你可能不需要这些信息。只关心当前屏幕上有多少 CSS 像素就好。

![](css3_img\屏幕大小.jpg)





### 缩放比例

你无法直接获得缩放比例，但是可以通过 `screen.widt` 和 `window.innerWidth` 的值求出来。当然只有两种属性都被支持时才有效。

幸运的是，缩放比例并不重要。你需要知道的是当前屏幕上有多少 CSS 像素，你可以通过 `window.innerWidth` 获得（如果该属性被支持的话）。







### 滚动偏移

你同样需要知道的是当前视觉视图相对于布局视图的位置。这就是滚动偏移，和桌面端一样，这个属性保存在 `window.pageX/YOffset` 中

![](css3_img\滚动偏移3.jpg)







### html页面真实大小

 和在桌面上一样， `document.documentElement.offsetWidth/Height` 可以获得 `<html>` 元素在 CSS 像素中的尺寸。

![](css3_img\html真实宽高3.jpg)





### 媒体查询

媒体查询的工作方式和在桌面端相同。 `width/height` 将布局视图作为参照，使用 CSS 像素计算。而 `device-width/height` 将设备屏幕作为参照，使用物理像素计算。

换句话说， `width/height` 表示 `document. documentElement. clientWidth/Height` 的值，而 `device-width/height` 表示 `screen.width/height` 的值。所有浏览器都是如此，即使它们表示的值是错误的。

![](css3_img\移动端媒体查询.jpg)

哪一种测算对web开发者更有用？我不知道。

我开始认为 `device-width` 是最重要的，因为它可以提供我们可能用到的设备信息。举例来说，你需要不同宽度的布局视图适应设备宽度。可是，你也可以使用 `<meta viewport>`，没有必要使用 `device-width` 的媒体查询。

那么 `width` 是更重要的媒体查询吗？也许是，有线索表示浏览器厂商认为这一数值对于设备上的网站是友好的宽度。但仍然有些含糊不清 `width` 的媒体查询没有提供更多的其他信息。

因此我仍然不确定。目前我认为媒体查询对于区分桌面、平板或手机很重要，但是对于区分不同的平板或手机用处不大。









### 事件坐标

 事件坐标和在桌面端多少有些差异。不幸的是，12 个测试浏览器中只有两个（Symbian WebKit 和 Iris）获得的三个属性的值完全正确。其他的浏览器或多或少的有些问题。

 `pageX/Y` 获取的仍是相对于页面的 CSS 像素。这也是目前为止最有用的属性对，和桌面端一样。

![](css3_img\pageX-Y2.jpg)

`clientX/Y` 是相对于视觉视图的 CSS 像素。这是有意义的，虽然我不确定到底有什么好处。

 `screenX/Y` 是相对于屏幕的设备像素。当然，它与 `clientX/Y` 的参照是相同的，而设备像素没什么用。所以我们不用关心 `screenX/Y` ，它在桌面端同样没什么用。

![](css3_img\screenX-Y2.jpg)